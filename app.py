import xml.etree.ElementTree as ET
import streamlit as st
import pandas as pd
import os
from pathlib import Path
import random
import datetime
import hashlib
import dropbox



# === Dropbox Setup (refresh token version) ===
def get_dropbox_client():
    import dropbox
    import os
    from dotenv import load_dotenv
    load_dotenv()

    try:
        APP_KEY = os.getenv("DROPBOX_APP_KEY", st.secrets["dropbox"]["app_key"])
        APP_SECRET = os.getenv("DROPBOX_APP_SECRET", st.secrets["dropbox"]["app_secret"])
        REFRESH_TOKEN = os.getenv("DROPBOX_REFRESH_TOKEN", st.secrets["dropbox"]["refresh_token"])

        dbx_client = dropbox.Dropbox(
            app_key=APP_KEY,
            app_secret=APP_SECRET,
            oauth2_refresh_token=REFRESH_TOKEN
        )
        # Quick check for validity
        dbx_client.users_get_current_account()
        print("‚úÖ Dropbox (refresh token) connection successful.")
        return dbx_client
    except Exception as e:
        print(f"‚ùå Dropbox connection failed: {e}")
        return None

if "dbx" not in st.session_state or st.session_state.dbx is None:
    st.session_state.dbx = get_dropbox_client()

dbx = st.session_state.dbx

# === Helper: Load config from Dropbox ===
def load_config_from_dropbox(filename):
    """Load configuration file from Dropbox App Folder (always from Dropbox, no local fallback)."""
    try:
        metadata, res = dbx.files_download(f"/config/{filename}")
        xml_data = res.content.decode("utf-8")
        return xml_data
    except Exception as e:
        return None

# === Load users directly from Dropbox XML (only once per session) ===
if "users_xml" not in st.session_state:
    xml_data = load_config_from_dropbox("users.xml")
    if not xml_data:
        st.error("Unable to load users.xml from Dropbox. Please check your Dropbox /config/ folder.")
        st.stop()
    else:
        st.session_state.users_xml = xml_data
else:
    xml_data = st.session_state.users_xml

root = ET.fromstring(xml_data)
VALID_USERS, USER_GROUPS = {}, {}
for u in root.findall('user'):
    name = u.get('name')
    password = u.get('password')
    group = u.get('group')
    VALID_USERS[name] = password
    USER_GROUPS[name] = group

AUDIO_ROOT = "./"
RESULTS_DIR = None  # Local results directory disabled; only Dropbox used

def upload_to_dropbox(local_path, filename):
    """Uploads a file to Dropbox App Folder."""
    try:
        with open(local_path, "rb") as f:
            dbx.files_upload(f.read(), f"/ratings/{filename}", mode=dropbox.files.WriteMode("overwrite"))
    except Exception as e:
        pass

st.set_page_config(page_title="üéß Emotion Evaluation", layout="wide")

st.markdown("""
<style>
div.row-widget.stRadio > div {
    flex-direction: row;
    justify-content: center;
    align-items: flex-start;
    gap: 0.8rem;
    margin-top: -10px;
}
.stRadio div[role="radiogroup"] {
    display: flex;
    justify-content: space-evenly;
    align-items: flex-start;
    width: 90%;
    margin: 0 auto;
}
.stRadio label {
    flex: 1;
    text-align: center;
    font-size: 0.9rem;
}
.stRadio div[role="radiogroup"] label:first-child {
    text-align: left;
}
.stRadio div[role="radiogroup"] label:last-child {
    text-align: right;
}
.block-container {
    max-width: 800px;
    padding-top: 1.5rem;
    padding-bottom: 1.5rem;
}
</style>
""", unsafe_allow_html=True)

if "page" not in st.session_state:
    st.session_state.page = "login"

# === Ba≈ülƒ±k ===
st.markdown(
    """
    <h3 style='text-align:center; font-weight:600; margin-top:0;'>Human Evaluation: Emotion Analysis of Text-To-Speech (TTS) Samples Generated by Generative Artificial Intelligence</h3>
    <div style='height: 2.5rem;'></div>
    """,
    unsafe_allow_html=True
)

if st.session_state.page == "login":
    st.markdown("""
Please enter your username and password below.""")
    username = st.text_input("Username", "")
    password = st.text_input("Password", type="password")

    # === User authentication ===
    if username and password:
        if username not in VALID_USERS or VALID_USERS[username] != password:
            st.error("Invalid username or password.")
        else:
            # Local completed files check disabled
            st.session_state.username = username
            st.session_state.page = "info"
            st.rerun()

elif st.session_state.page == "info":
    st.markdown("""
**Thank you for your participation in this study.**  
Below you will find detailed information about the study's purpose, procedure, personal data confidentiality, and the voluntary nature of participation. Please read this information carefully.

---

### Purpose of the Study
The main objective of this study is to measure the **effectiveness and naturalness of emotional expressions** (happiness, sadness, anger, fear, neutral, surprise, disgust) in audio texts generated by different Generative Artificial Intelligence (GenAI) models using Text-to-Speech (TTS) technology, as perceived by human listeners.  
The data obtained will contribute to improving the emotional expressiveness of AI-generated voices.

---

### Study Procedure
- **Listening and Evaluation:** You will be presented with audio samples generated by four (4) different GenAI models, each designed to convey specific emotional states.  
- After listening to each audio sample, you will be asked to make **two separate evaluations**:
    1. **Emotion Effectiveness:** Please evaluate how effectively and appropriately the intended emotion (e.g., anger, sadness, joy) is expressed in the speech ‚Äî independent of the text itself.  
    2. **Voice Naturalness:** Please evaluate how natural and human-like the voice sounds, regardless of the emotion expressed.
- **Scoring Scale:** For both evaluations, use a **7-point scale** from **1 (Very Low)** to **7 (Very High)** to indicate your judgment of emotional effectiveness and naturalness.
- **Duration:** The total time to complete this evaluation is approximately **10 minutes**.

---

### Voluntary Participation and Withdrawal
Your participation in this study is **completely voluntary**.  
You have the right to withdraw at any time without providing any reason. If you withdraw, any incomplete responses will not be used in the analysis.

---

### Confidentiality of Personal Data
- This study does **not** collect any personally identifiable information such as your name, address, or national ID.  
- All data (your ratings) will be processed **anonymously** and used only for scientific purposes.  
- The dataset will not contain any identifying information that could link results back to you.  
- When results are published, all findings will be reported in **aggregate form** without identifying individuals.  
- All collected data will be securely stored according to scientific and ethical standards.

---

### Researcher Contact Information
**Dr. Ahmet Remzi √ñZCAN** ‚Äî [ahmet.ozcan@btu.edu.tr](mailto:ahmet.ozcan@btu.edu.tr) ‚Äî +90 544 740 3272  
**Dr. G√∂khan Alper Fƒ∞GEN** ‚Äî [galperfigen@odu.edu.tr](mailto:galperfigen@odu.edu.tr) ‚Äî +90 505 299 0074  

Thank you once again for your participation and valuable contribution.
""")
    if st.button("Start Evaluation"):
        st.session_state.page = "evaluation"
        st.rerun()

# The "completed" page is only meaningful if local progress files are used.

elif st.session_state.page == "evaluation":
    rater_name = st.session_state.username

    group_name = USER_GROUPS[rater_name]  # e.g., group_1
    candidate1 = os.path.join("split_groups", rater_name, f"{group_name}.csv")
    candidate2 = os.path.join("split_groups", f"{group_name}.csv")

    if os.path.exists(candidate1):
        DATA_CSV = candidate1
    elif os.path.exists(candidate2):
        DATA_CSV = candidate2
    else:
        st.error(f"CSV not found: {candidate1} or {candidate2}")
        st.stop()

    # === Veri y√ºkle ===
    df = pd.read_csv(DATA_CSV)

    # --- Stabil (kullanƒ±cƒ±ya √∂zg√º) sƒ±ra: yalnƒ±zca bir kez olu≈üturulup saklanƒ±r ---
    if "order" not in st.session_state or len(st.session_state.get("order", [])) != len(df):
        indices = list(range(len(df)))
        # Kullanƒ±cƒ±ya √∂zg√º deterministik seed
        seed = int(hashlib.md5(rater_name.encode("utf-8")).hexdigest()[:8], 16)
        rnd = random.Random(seed)
        rnd.shuffle(indices)
        st.session_state.order = indices

    # Sƒ±rayƒ± uygula (her rerun'da aynƒ± sƒ±ra korunur)
    df = df.iloc[st.session_state.order].reset_index(drop=True)

    # === Kaldƒ±ƒüƒ± yerden devam etme i√ßin ilerleme dosyasƒ± (Dropbox only) ===
    import io
    import dropbox.exceptions
    if "i" not in st.session_state or "ratings" not in st.session_state:
        try:
            metadata, res = dbx.files_download(f"/ratings/{rater_name}_progress.csv")
            progress_df = pd.read_csv(io.StringIO(res.content.decode('utf-8')))
            metadata, res_idx = dbx.files_download(f"/ratings/{rater_name}_current_index.txt")
            st.session_state.i = int(res_idx.content.decode('utf-8').strip() or 0)
            st.session_state.ratings = progress_df.to_dict(orient="records")
            for r in st.session_state.ratings:
                if "rating" not in r:
                    r["rating"] = None
                if "naturalness" not in r:
                    r["naturalness"] = None
        except dropbox.exceptions.ApiError:
            st.session_state.i = 0
            st.session_state.ratings = [{} for _ in range(len(df))]

    i = st.session_state.i
    if i >= len(df):
        st.success("üéâ Evaluation completed! Thank you.")
        # Save results
        filled = [r for r in st.session_state.ratings if r.get("rating") is not None]
        ts = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
        out_name = f"{rater_name}_ratings_{ts}.csv"
        try:
            csv_data = pd.DataFrame(filled).to_csv(index=False)
            dbx.files_upload(csv_data.encode('utf-8'),
                             f"/ratings/{out_name}",
                             mode=dropbox.files.WriteMode("overwrite"))
            st.write(f"Results saved to Dropbox: `{out_name}`")
        except Exception as e:
            st.warning(f"Dropbox upload failed: {e}")
        st.stop()

    # === Mevcut √∂rnek ===
    row = df.iloc[i]
    emotion = row["emotion"]
    audio_path = os.path.join(AUDIO_ROOT, row["wav_path"])

    st.markdown(
        f"""
        <div style='display:flex; justify-content:space-between; align-items:center;'>
            <h4 style='margin:0;'>üéß Sample {i+1}/{len(df)}</h4>
            <h5 style='margin:0; text-align:right; font-style:italic;'>Target Emotion: <strong>{emotion.upper()}</strong></h5>
        </div>
        """,
        unsafe_allow_html=True
    )
    if os.path.exists(audio_path):
        with open(audio_path, "rb") as f:
            audio_bytes = f.read()
        st.audio(audio_bytes, format="audio/wav")
    else:
        st.error(f"File not found: {audio_path}")


    # Load previous selections if any, otherwise leave empty
    if i < len(st.session_state.ratings) and st.session_state.ratings[i].get("rating") is not None:
        existing = st.session_state.ratings[i]
        default_rating = existing.get("rating")
        default_naturalness = existing.get("naturalness")
    else:
        existing = {}
        default_rating = None
        default_naturalness = None

    import math
    # Convert to radio indices safely (handle NaN or None)
    if default_rating is None or (isinstance(default_rating, float) and math.isnan(default_rating)):
        rating_index = None
    else:
        rating_index = [1, 2, 3, 4, 5, 6, 7].index(int(default_rating))

    if default_naturalness is None or (isinstance(default_naturalness, float) and math.isnan(default_naturalness)):
        naturalness_index = None
    else:
        naturalness_index = [1, 2, 3, 4, 5, 6, 7].index(int(default_naturalness))

    # Emotion effectiveness question
    st.markdown(
        f"<p style='text-align:left; font-size:1.1rem; font-weight:300;'>1. Please evaluate how effectively the emotion of <strong>{emotion.upper()}</strong> is conveyed in this speech on a scale from 1 (Very Low) to 7 (Very High).</p>",
        unsafe_allow_html=True
    )
    rating_label = st.radio(
        "Emotion Effectiveness",
        options=[1, 2, 3, 4, 5, 6, 7],
        index=rating_index,
        horizontal=True,
        captions=["Very Low", "", "", "", "", "", "Very High"],
        key=f"rating_{i}_{row['wav_path']}",
        width="stretch",
        label_visibility="collapsed"
    )

    # Voice naturalness question
    st.markdown(
        "<p style='text-align:left; font-size:1.1rem; font-weight:300;'>2. Please evaluate how <strong>natural</strong> this voice sounds on a scale of 1 (Very Low) to 7 (Very High):</p>",
        unsafe_allow_html=True
    )
    naturalness_label = st.radio(
        "Voice Naturalness",
        options=[1, 2, 3, 4, 5, 6, 7],
        index=naturalness_index,
        horizontal=True,
        captions=["Very Low", "", "", "", "", "", "Very High"],
        key=f"naturalness_{i}_{row['wav_path']}",
        width="stretch",
        label_visibility="collapsed"
    )

    # Determine if user can proceed
    can_proceed = rating_label is not None and naturalness_label is not None

    st.markdown("<br>", unsafe_allow_html=True)  # spacing before buttons

    # Add equal-width columns with spacing and button style
    col1, col_spacer, col2 = st.columns([3, 3, 3])

    button_style = """
        <style>
        div.stButton > button {
            width: 100%;
            padding: 0.8em 0.8em;
            font-size: 1.1rem;
            border-radius: 8px;
            font-weight: 500;
        }
        </style>
    """
    st.markdown(button_style, unsafe_allow_html=True)

    def save_progress():
        """Save current ratings and index directly to Dropbox (no local copy)."""
        try:
            csv_data = pd.DataFrame(st.session_state.ratings).to_csv(index=False)
            index_str = str(st.session_state.i)
            dbx.files_upload(csv_data.encode('utf-8'),
                             f"/ratings/{rater_name}_progress.csv",
                             mode=dropbox.files.WriteMode("overwrite"))
            dbx.files_upload(index_str.encode('utf-8'),
                             f"/ratings/{rater_name}_current_index.txt",
                             mode=dropbox.files.WriteMode("overwrite"))
        except Exception as e:
            st.error(f"Dropbox save failed: {e}")

    # Eƒüer ratings uzunluƒüu farklƒ± ise d√ºzelt
    if len(st.session_state.ratings) != len(df):
        st.session_state.ratings = [{} for _ in range(len(df))]

    with col1:
        prev_disabled = not can_proceed and i == 0
        if st.button("‚¨ÖÔ∏è Previous", disabled=prev_disabled):
            if st.session_state.i > 0:
                st.session_state.ratings[i] = {
                    "rater": rater_name,
                    "idx": row.get("prompt_id", ""),
                    "tts": row["tts"],
                    "emotion": emotion,
                    "wav_path": row["wav_path"],
                    "rating": rating_label,
                    "naturalness": naturalness_label,
                }
                st.session_state.i -= 1
                save_progress()
                st.rerun()

    with col2:
        if st.button("Save and Next ‚û°Ô∏è", disabled=not can_proceed):
            st.session_state.ratings[i] = {
                "rater": rater_name,
                "idx": row.get("prompt_id", ""),
                "tts": row["tts"],
                "emotion": emotion,
                "wav_path": row["wav_path"],
                "rating": rating_label,
                "naturalness": naturalness_label,
            }
            st.session_state.i += 1
            save_progress()
            st.rerun()